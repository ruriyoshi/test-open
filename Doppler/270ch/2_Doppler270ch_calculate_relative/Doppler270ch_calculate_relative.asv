%----------
%input: calib_filename='Doppler270ch_Ar_dial4820.xlsx';
%このとき，instruはすべて0としておく。
%output: filename='Doppler270ch_determine_smile_and_instru.xlsx';
%----------

close all
% clear all
% load("230712_base.mat","data")

%各PCのパスを定義
% run define_path.m
%setenv("NIFS_path","N:\")%NIFSのresultsまでのパスを入れる
pathname.NIFS=getenv('NIFS_path');%resultsまでのpath（ドップラー、SXR）
pathname.IDS270ch=[pathname.NIFS,'/Doppler/Andor/270CH'];

%------【input】---------------------------------------------------
date = 230917;%【input】実験日
ICCD.line = 'Ar';%【input】ドップラー発光ライン('Ar')
target_slit=1;

read_data = true;%【input】データをascファイルから読み込む

plot_ICCD = true;%【input】ICCD画像をプロット

cal_CH = true;%【input】CHごとのスペクトルを取得

cal_LineInt = true;%【input】線積分イオン温度、発光強度分布を計算
plot_LineInt_result = true;%【input】線積分イオン温度、発光強度分布をプロット

cal_2D = true;%【input】アーベル変換して2次元イオン温度、発光強度分布を計算
plot_2D_result = true;%【input】2次元イオン温度、発光強度分布をプロット
plot_profile = true;%【input】イオン温度R分布をプロット

%-----------------------解析オプション【input】----------------------------
plot_CH_spectra = true;%【input】CHごとのスペクトルをプロット(cal_CH = trueが必要)
plot_LineInt_interp = false;%【input】死んだCHの補間Ti,Emをプロット(cal_LineInt = trueが必要)
plot_2D_interp = false;%【input】補間スペクトルをプロット(cal_2D = trueが必要)
plot_2D_spectra = 'off';%【input】('off','all','good','bad')2次元スペクトル分布をプロット(cal_2D = trueが必要)

hw_lambda = 150;%【input】波長切り出し半幅->input:調整する
hw_ch = 5;%【input】CH方向切り出し半幅
hw_fit = 12;%【input】フィッティング波長切り出し半幅(< hw_lambda)
num_r = 30;%【input】r分割数(比例して計算時間が増える)
hw_lambdaA = 40;%【input】lambdaA半幅(< hw_lambda)
%------------------------------------------------------------------

%物理定数
switch ICCD.line
    case 'Ar'
        lambda0 = 480.6;%471.3;656.3;480.6;587.562;486.133;656.3;486.133;468.57;486.133;nm%線スペクトル波長
        mass = 39.95;%4.;12.01%イオン質量数
    otherwise
        warning('Input error in ICCD.line.')%ICCD.lineの入力エラー
        return;
end

%------校正値(1つのファイルにまとめたい)---------------------------------
%separation = [0 15 31 45 57 73 89 105 120 136 152 164 180 196 211 226 240 255];%CHをZ方向で切り分けるための値%todo
resolution = -1.420387E-12*lambda0^3 - 2.156031E-09*lambda0^2 + 1.250038E-06*lambda0 + 3.830769E-03;0.0037714;...
    %-0.000000000001420387*lambda0^3 - 0.000000002156031*lambda0^2 + 0.000001250038*lambda0 + 0.003830769
%z = importdata("z_negative.txt")*1e-3;%計測視線Z[m]
%p = importdata("r.txt")*1e-3;%計測視線と中心軸の距離P[m]->todo:270chではzによって違うはず
edge = 0.33;%Rの最大値[m](2022/7　解析～　ポテンシャルの範囲より仮定)
%calib = importdata("Ar_calibration.0916_remake.txt");%ICCD校正ファイル

%較正係数のバージョンを日付で判別
calib_filename='Doppler270ch_Ar_dial4820.xlsx';
sheets = sheetnames(calib_filename);
sheets = str2double(sheets);
sheet_date=max(sheets(sheets<=date));
C = readmatrix(calib_filename,'Sheet',num2str(sheet_date));
z_index=C(:,6);
slit=zeros(size(z_index));
z=unique(C(:,7))*1e-3;%計測点のZ座標[m]

for i=1:numel(slit)
    switch z_index(i)
        case {1,2,3}
            slit(i)=1;
        case {4,5}
            slit(i)=2;
        case {6,9}
            slit(i)=3;
        case {7,10}
            slit(i)=4;
        case {8,11}
            slit(i)=5;        
    end
end
%------------------------------------------------------------------
%%
if read_data
    %データ読み込み(GUI)
    dir = [pathname.IDS270ch,'/20',num2str(date)];%実験日ディレクトリ
    [file,path] = uigetfile('*.asc','Select a file',dir);
    if isequal(file,0)
        disp('User selected Cancel');
        return
    else
        disp(['User selected ', fullfile(path,file)]);
        filename = fullfile(path,file);
    end
    % %データ読み込み(手入力)
    % filename = [dir,'/shot3_PF39_TF-2_EF120_gas0.62_delay468_width3.asc'];
    %スペクトルを取得
    data = importdata(filename);
    data = data(:,2:1025);%1列目は分光データではないので削除
end
tic
%%
fig_num=1;%グラフ番号の初期化
screensize=get(0,'screensize');
fig_position=[0,50,screensize(3)-50,screensize(4)-150];

%校正ファイル読み込み
% ch = calib.data(:,1);
% center = calib.data(:,2);
% smile = calib.data(:,3);
% relative = calib.data(:,5);
% instru = calib.data(:,6);
target_index=find(slit==target_slit);
ch=C(target_index,1);
center=round(C(target_index,2),0);%calibファイルが小数なので，四捨五入
smile=C(target_index,3)+180;%input:中央になるまで調整
relative=C(target_index,4);
instru=C(target_index,5);
Ti_instru_CH = 1.69e8*mass*(2.*resolution*instru*sqrt(2.*log(2.))/lambda0).^2;

%各CHの波長軸を生成
lambda = zeros(1024,numel(ch));
idx_l0 = zeros(numel(ch),1);
px = transpose(linspace(1,1024,1024));
for i=1:numel(ch)
    lx=(px-1-smile(i))*resolution+lambda0;%+0.13
    idx_l0(i) = knnsearch(lx,lambda0);%lambdaの中で最もlambda0に近いセル番号を取得
    lambda(:,i) = lx;
end

%ICCD生画像を描画(目視で確認用)
if plot_ICCD
    %figureの設定
    fig_num=fig_num+1;
    f=figure(fig_num);
    f.Position=fig_position;

    %1枚目(左)
    subplot(1,2,1)
    contourf(px,px,data',50,'LineStyle','none')%変える
    colormap turbo
    colorbar
    
    title('ICCD Raw Image')
    xlabel('X　(lambda) [px]')
    ylabel('Y (position) [px]')
    hold on
    for i=1:numel(ch)
        hol_X = linspace(smile(i)-hw_lambda,smile(i)+hw_lambda);
        hol_Y = center(i)*ones(100,1);
        plot(hol_X,hol_Y,'r')
        hold on
        ver_X = smile(i)*ones(100,1);
        ver_Y = linspace(center(i)-hw_ch,center(i)+hw_ch);
        plot(ver_X,ver_Y,'r','LineWidth',1)
    end
    % ylim([900 1024])
    hold off
    %ICCD生画像をCH方向に足し合わせたもののフィッティング(目視で確認用)
    sum_data = sum(data,2);
    offset_sum = min(movmean(sum_data,10));
    sum_data = sum_data - offset_sum;
    f = fit(px,sum_data,'gauss5');
    coeff5=coeffvalues(f);
    % centerL = [coeff5(2),coeff5(5),coeff5(8),coeff5(11),coeff5(14)];
    % centerL = round(sort(centerL));
    subplot(1,2,2)
    plot(f,px,sum_data')
    title('ICCD Integrated Image')
    xlabel('X [px]')
    ylabel('Strength [a.u.]')
    xlim([1 1024])
    ylim([0 inf])
    hold off
end
%%
%-------CHごとの線積分温度、線積分発光強度を計算--------
smile_new=zeros(numel(ch),1);

if cal_CH
    hw_plot_px = hw_lambda;%プロット範囲半幅
    col_subp1 = 2;%サブプロット行数
    raw_subp1 = 2;%サブプロット列数
    n_subp1 = col_subp1*raw_subp1;
    passive_Ti = zeros(numel(ch),1);%CH温度[eV]
    passive_Timax = zeros(numel(ch),1);%CH温度95%信頼区間上限[eV]
    passive_Timin = zeros(numel(ch),1);%CH温度95%信頼区間下限[eV]
    passive_Em = zeros(numel(ch),1);%CH発光強度[a.u.]
    spectra = zeros(numel(data(:,1)),numel(ch));%CHスペクトル
    
    relative
    for i=1:numel(ch)
        spectra(:,i) = sum(data(:,center(i)-hw_ch:center(i)+hw_ch),2)*relative(i);%binning
        offset = min(movmean(spectra(:,i),20));
        spectra(:,i) = spectra(:,i) - offset;%オフセットを引く
        f = fit(lambda(:,i),spectra(:,i),'gauss1');
        coeff = coeffvalues(f);%フィッティング係数
        % coeff(3)/resolution/sqrt(2);%IDLのcoeff[2]に等しい(確認用)
        % Sigma(i) = coeff(3)/sqrt(2);

        %coeff(2):coeffの2番目は，ピーク波長がいくらと計算されたかを表している
        %coeff(2)>lambda0の場合，smile(i)は実際よりも小さく設定された
        %coeff(2)<lambda0の場合，smile(i)は実際よりも大きく設定された
        %これを補正して，今度はcoeff(2)=lambda0となるようにsmile_newを新しく設定する
        smile_new(i)=smile(i)+coeff(2)-lambda0;

        confi = confint(f);%フィッティング係数の95%信頼区間(1行目下限, 2行目上限)
        passive_Ti(i) = 1.69e8*mass*(2*coeff(3)*sqrt(log(2))/lambda0)^2-Ti_instru_CH(i);
        passive_Timax(i) = 1.69e8*mass*(2*confi(2,3)*sqrt(log(2))/lambda0)^2-Ti_instru_CH(i);
        passive_Timin(i) = 1.69e8*mass*(2*confi(1,3)*sqrt(log(2))/lambda0)^2-Ti_instru_CH(i);
        passive_Em(i) = resolution*sum(spectra(:,i));
        if plot_CH_spectra
            idx_subp1 = mod(i-1,n_subp1)+1;%サブプロット位置番号
            if i == 1
                figure('Position',[0 500 400 300])
                sgtitle('Line Integrated Spectra')
            end
            subplot(col_subp1,raw_subp1,idx_subp1)
            if i <= n_subp1
                if i == 1
                    fit_x = transpose(linspace(lambda0-hw_plot_px*resolution,lambda0+hw_plot_px*resolution,100));
                    fit_y = feval(f,fit_x);
                    pfit1 = plot(fit_x,fit_y,'r-',lambda(hw_lambda+1-hw_plot_px:hw_lambda+1+hw_plot_px,i),spectra(hw_lambda+1-hw_plot_px:hw_lambda+1+hw_plot_px,i),'b+');%フィティングあり
                    pfit = repmat(pfit1,[1,1,n_subp1]);
                else
                    fit_y = feval(f,fit_x);
                    pfit(:,:,idx_subp1) = plot(fit_x,fit_y,'r-',lambda(hw_lambda+1-hw_plot_px:hw_lambda+1+hw_plot_px,i),spectra(hw_lambda+1-hw_plot_px:hw_lambda+1+hw_plot_px,i),'b+');%フィティングあり
                end
                xline(lambda0)
                title(['CH',num2str(ch(i))])
                xlabel('Wavelength [nm]')
                ylabel('Strength [a.u.]')
                xlim([lambda0-hw_plot_px*resolution lambda0+hw_plot_px*resolution])
                ylim([0 inf])
                legend('off')
            else
                fit_y = feval(f,fit_x);
                pfit(1,:,idx_subp1).YData = fit_y;
                pfit(2,:,idx_subp1).XData = lambda(hw_lambda+1-hw_plot_px:hw_lambda+1+hw_plot_px,i);
                pfit(2,:,idx_subp1).YData = spectra(hw_lambda+1-hw_plot_px:hw_lambda+1+hw_plot_px,i);
                title(['CH',num2str(ch(i))])
                drawnow
            end
        end
    end
end

%Ti_instru_CH = 1.69e8*mass*(2.*resolution*instru*sqrt(2.*log(2.))/lambda0).^2;
%の逆計算をしてからinstru_newに入れる
instru_new=sqrt(passive_Ti/1.69e8/mass)*lambda0/2./resolution/sqrt(2.*log(2.));
T=table(smile_new,instru_new);
filename='Doppler270ch_determine_smile_and_instru.xlsx';
writetable(T,filename);